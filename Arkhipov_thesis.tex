%\documentclass[12pt,twoside,a4paper]{report}
\documentclass[twoside]{report}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{spbstuthesis}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{alltt}
%%для замены текста на рисунках
%\usepackage{psfrag}

%\ministrycontest{Пролетарии всех стран, соединяйтесь!}{Тема работы}
\masters{Разработка и реализация алгоритма синтеза систем переходов для $GR(1)$-формул при помощи BDD}{02.04.02 <<Фундаментальная  информатика и информационные технологии>>}{02.04.02\_02 <<Проектирование сложных информационных систем>>}{63507}{Т.~Д. Архипов}{к.т.н., доц.}{И.В. Шошмина}

\Abstract{

В данном исследовании рассматривается задача синтеза контроллера для реагирующей системы по заданным требованиям. Для уменьшения алгоритмической сложности синтеза требования представляются с помощью подкласса LTL-формул - GR(1)-формул.

При заданной реагирующей системе для предъявляемых к ней требований в виде GR(1)-формулы производится проверка, являются ли они реализуемыми, и, если так, производится синтез совместного контроллера, заданную формулу реализующего. Синтез системы переходов реализован символьным методом, при этом символьная запись хранится в памяти в виде BDD.

Для уменьшения количества состояний синтезированной системы к ней применяется алгоритм минимизации.
После минимизации синтезированная модель системы транслируется в формат DOT для ее последующей визуализации.

Алгоритм синтеза систем переходов по GR(1)-формулам, на который опирается основная часть реализации, описан в статье [1. PPS06]. (N. Piterman, A. Pnueli, Y. Sa'ar "Synthesis of reactive(1) designs", VMCAI 3855, 364-380, 2006)


}{Brief description of the work, main result, keywords}

\begin{document}

\sloppy
\maketitle
\task{Т.~Д. Архипову}{
\item Срок сдачи работы.
\item Исходные данные к проекту (работе).
\item Содержание расчетно-пояснительной записки (перечень подлежащих 
разработке вопросов).
\item Перечень графического материала с точным указанием обязательных 
чертежей.
\item Консультанты по проекту (с указанием относящегося к ним разделов 
проекта, работы).
}
\makeabstract

\tableofcontents

\Chapter{Список обозначений}
\begin{tabular}{ll}
BDD& Binary Decision Diagrams: бинарные решающие диаграммы\\
LTL& Linear Temporal Logic: линейная темпоральная логика\\
\end{tabular}



%%%%%
\Chapter{Введение}

% 
% Рекомендуемый объем главы --- 1--2 стр.
% Во введении приводится  обоснование актуальности темы, формулировка основной цели работы, 
% краткое описание решенной задачи и научно-технического содержания.
% Кроме того, рекомендуется в явном виде описать структуру работы в соответсвии с 
% нижеприведенным образцом.
% 
% 
% Работа организована следующим образом. В главе \ref{cReview} представлен 
% обзор проблемы создания вечного двигателя. Глава \ref{cDesign} содержит 
% описание предлагаемого подхода к его построению. Вопросы его практической 
% реализации рассмотрены в главе \ref{cImplementation}. Результаты 
% экспериментального исследования его эффекивности приведены в главе 
% \ref{cExperiments}. В приложении \ref{cHints} приведены правила оформления 
% различных элементов работы и рекомендации по использованию инструментария 
% \LaTeX.
% 
В данном исследовании рассматривается задача синтеза контроллера для реагирующей системы по заданным требованиям. Для уменьшения алгоритмической сложности синтеза требования представляются с помощью подкласса LTL-формул - GR(1)-формул.

При заданной реагирующей системе для предъявляемых к ней требований в виде GR(1)-формулы производится проверка, являются ли они реализуемыми, и, если так, производится синтез совместного контроллера, заданную формулу реализующего. Синтез системы переходов реализован символьным методом, при этом символьная запись хранится в памяти в виде BDD.

Для уменьшения количества состояний синтезированной системы к ней применяется алгоритм минимизации.
После минимизации синтезированная модель системы транслируется в формат DOT для ее последующей визуализации.

Алгоритм синтеза систем переходов по GR(1)-формулам, на который опирается основная часть реализации, описан в статье ~\cite{Piterman2006}

%%%%%%%%%%%%%
\chapter{Постановка задачи синтеза систем переходов из GR--формул}

\section{LTL}
Синтаксис при помощи формул. Семантика. Представление в виде систем переходов (здесь имеет смысл писать об недетерминированных автоматах Бюхи только).

\section{Задача выполнимости LTL--формул. Задача выполнимости LTL--формул на конкретной системе переходов.}
Метод проверки модели как способ решения.

\section{LTL--формулы с переменными разного типа}
Среда, система. Задача реализуемости таких формул -- задача выполнимости в логике высокого порядка. 
Сложность решения такой задачи в общем случае.

\section{GR--формулы синтаксис и семантика}
?GR--формулы. Просто дискретные системы (детерминированные автоматы Бюхи)

Задача реализуемости GR--формул. Задача синтеза контроллера. Сложность задачи реализуемости

\section{Постановка задачи символьного представления систем переходов}
{Символьное представление систем переходов}
+BDD

Цель работы --- 

Задачи работы ---



%%%%%%%%%%%%
\chapter{Алгоритм синтеза GR--формул}

\section{Задача синтеза как задача построения отображения}
Справедливая симуляция. Симуляционная игра.

\section{Решение задачи синтеза с помощью мю--уравнения}
Мю--исчисление. Мю--уравнение. Теорема о реализуемости. Алгоритм.
Синтезируемая система переходов.

\section{Символьная реализация алгоритма}
Прямой, обратный образы, cox



%%%%%%%%%%%
\chapter{Реализация алгоритма синтеза GR--формул}

\section{Архитектура программного средства}
Работа синтеза была реализована на языке $c++$, для сборки проекта использовался компилятор $MSVC++$ версии 11.0 ($_MSC_VER == 1700$).

\subsection{BuDDy}
В процессе синтеза предполагается работа с символьным описанием состояний, требований и систем переходов, которое представляется программно в виде BDD. Для работы с BDD используется пакет $BuDDy$~\cite{LindNielsen2002}. Ниже описаны ключевые моменты работы с библиотекой $BuDDY$.

Для подключения и использования библиотеки необходимо скачать пакет $BuDDy$: $https://sourceforge.net/projects/buddy/$ и произвести его сборку на своей рабочей машине. Далее необходимо включить библиотеку и заголовочный файл $bdd.lib, bdd.h$ в исходный файл, работающий с BDD, добавлением следующего кода:
\begin{verbatim}
#pragma comment(lib, "bdd.lib")	// BuDDy library
#include "bdd.h"
\end{verbatim}

Сперва необходимо инициализировать пакет BDD с помощью команды:
\begin{verbatim}
	bdd_init(nodenum,cachesize);
//Для больших примеров --- nodenum~10000000,cachesize~1000000
%	bdd_setcacheratio(10);
\end{verbatim}
где $nodenum$ --- начальное количество выделенных вершин BDD, $cachesize$ --- размер кэша, используемого при выполнении операций над BDD.

После инициализации необходимо установить количество переменных BDD, с помощью которых будет кодироваться символьная запись.
\begin{verbatim}
	bdd_setvarnum(unsigned N);
\end{verbatim}
Однако, в нашем случае сразу вычислять количество переменных BDD неудобно, поэтому в программе используется постепенное увеличение количества переменных по мере их прочтения с помощью функции:
\begin{verbatim}
	bdd_extvarnum(unsigned N);
\end{verbatim}

В программе используются переменные двух типов --- двоичного и перечислимого. Для кодирования каждой символьной переменной необходимо выделять двукратное количество переменных BDD, так как в каждом требовании к поведению может быть два вида каждой переменной --- $var$ и $next(var)$ (то же самое, что $var'$). Поэтому для каждой переменной верно следующее:
\begin{itemize}
\item Для кодирования булевых переменных выделяется 2 переменные BDD
\item Для кодирования переменных перечислимого типа выделяется $\lceil \log_2 (N) \rceil$, где $N$ --- количество возможных значений переменной
\end{itemize}

Любая булева функция может быть представлена с помощью BDD. Для этого в $BuDDy$ используются следующие атомарные функции:


\begin{itemize}
\item bdd\_ithvarpp(unsigned i); --- описывается BDD с одной вершиной, соответствующее булевой функции $v_i$
\begin{tikzpicture}
\Tree [.\node[draw, circle]{$v_i$}; \edge[dashed]; \node[draw]{0}; \node[draw]{1};]
\end{tikzpicture}

\item bdd\_nithvarpp(unsigned i); --- описывается BDD с одной вершиной, соответствующее булевой функции $v_i$
\begin{tikzpicture}
\Tree [.\node[draw, circle]{$v_i$}; \node[draw]{0}; \edge[dashed]; \node[draw]{1};]
\end{tikzpicture}
\item bddtruepp; --- константа $true$
\begin{tikzpicture}
\path
%	(0,1) node[circle,inner sep=3pt,draw] (v){$v_i$}
	(0,0) node[draw] (val){1};
%\draw[dotted,black] (v) .. controls (-0.5,0.5) .. node[near start,sloped] {} (val);
%\draw[-,black] (v) .. controls (0.5,0.5) .. node[near start,sloped] {} (val);
\end{tikzpicture}
\item bddfalsepp; --- константа $false$
\begin{tikzpicture}
\path
%	(0,1) node[circle,inner sep=3pt,draw] (v){$v_i$}
	(0,0) node[draw] (val){0};
%\draw[dotted,black] (v) .. controls (-0.5,0.5) .. node[near start,sloped] {} (val);
%\draw[-,black] (v) .. controls (0.5,0.5) .. node[near start,sloped] {} (val);
\end{tikzpicture}
\end{itemize}

Получение функции из набора переменных и из другий логических функций происходит с использованием операций $\verb’&, |, \^, >>, bdd_not’$, либо с помощью функции $bdd\_apply(bdd_1, bdd_2, bddop)$, где $bddop$~--- это любой логический оператор ($bddop\_or, bddop\_and,$ и так далее).

\subsection{язык SMV}
На языке SMV описываются модули~--- модели среды и системы. В описание модулей входит: описание их внутренних переменных, их начальных состояний, правила переходов среды и системы. Также описываются условия справедливости, требующие определенного поведения модулей.

Описание грамматики языка SMV не стандартизировано: в каждом проекте используемый синтаксис языка может отличаться. Однако, одно из наиболее полных описаний языка представлено в статье~\cite{NuSMV25_2010}

Язык, на котором описываются модули для данного программного средства, основан на SMV и включает в себя его часть. Ниже представлено описание грамматики данного языка:

\verb’MODULE <name>[<args>] <body> :: ’\\
	| \qquad \verb’"MODULE main VAR " atom ":" moduleName ";" Modules’\\

Modules ::\\
	| \qquad \verb’Module "\n" Modules’\\
	| \qquad $\varepsilon$\\

Module :: --- модель недетерминированный конечный автомат\\
	| \qquad \verb’"MODULE " atom "(" args ")" ModuleData’ - Аргументы системы - это внешние переменные. Текущая система не может их устанавливать - внутри её правил переходов к этим переменным не может применяться оператор $next()$\\

ModuleData ::\\
	| \qquad \verb’"VAR" Variables ModuleData’ - описание внутренних переменных данной системы переходов\\
	| \qquad \verb’"ASSIGN" Assign ModuleData’ - описание начальных состояний у внутренних переменных\\
	| \qquad \verb’"TRANS" Trans ";" ModuleData’ - описание правил переходов\\
	| \qquad \verb’"JUSTICE" JusticeAll ModuleData’ - \\
	| \qquad $\varepsilon$\\

Variables ::\\
	| \qquad \verb’VarName ":" VarType ";" Variables’\\
	| \qquad $\varepsilon$\\

VarName ::\\
	| \qquad \verb’atom’\\

VarType ::\\
	| \qquad \verb’"boolean"’\\
	| \qquad "{" $VarValues$ "}"\\

VarValues ::\\
	| \qquad \verb’VarValue ", " VarValues’\\
	: \qquad \verb’VarValue’\\

VarValue ::\\
	| \qquad \verb’atom’\\

Assign ::\\
	| \qquad \verb’"init(" atom ") := " VarValue ";" Assign’\\
	| \qquad $\varepsilon$\\

VarValue ::\\
	| \qquad \verb’"TRUE"’ - константное значение $true$ для переменных типа $boolean$\\
	| \qquad \verb’"FALSE"’ - константное значение $false$ для переменных типа $boolean$\\
%	| \qquad \verb’atom’ - константные значения для переменных перечислимого типа\\

Transition :: --- символьные правила переходов системы, представленные булевыми формулами. Доролнительно используется оператор $next()$\\
	| \qquad \verb’VarName’\\
	| \qquad \verb’"!" VarName’	- логический оператор "НЕ"\\
	| \qquad \verb’"!" (Expression)’	- логический оператор "НЕ"\\
	| \qquad \verb’Expression "&" Expression’		- оператор "И"\\
	| \qquad \verb’Expression "|" Expression’		- оператор "ИЛИ"\\
	| \qquad \verb’Expression "->" Expression’		- оператор "импликация"\\
	| \qquad \verb’Expression "<->" Expression’	- оператор "эквивалентность"\\
	| \qquad \verb’Expression "!=" Expression’		- оператор "XOR" (сложение по модулю 2)\\
	| \qquad \verb’"next(" VarName ")"’	- LTL-оператор X (Next)\\
	| \qquad \verb’"(" Expression ")"’\\

JusticeAll :: - Каждое требование справедливости  интерпретируется с префиксом из операторов GF: "в системе переходов бесконечно часто верна булева формула Justice".\\
	| \qquad \verb’Justice ";" JusticeAll’\\
	| \qquad \verb’Justice’\\

Justice :: - требования справедливости, представленные булевыми формулами. Не используется оператор $next()$.\\
	| \qquad \verb’VarName’\\
	| \qquad \verb’"!" VarName’	- оператор "НЕ"\\
	| \qquad \verb’"!" (Expression)’	- оператор "НЕ"\\
	| \qquad \verb’Expression "&" Expression’		- оператор "И"\\
	| \qquad \verb’Expression "|" Expression’		- оператор "ИЛИ"\\
	| \qquad \verb’Expression "->" Expression’		- оператор "импликация"\\
	| \qquad \verb’Expression "<->" Expression’	- оператор "эквивалентность"\\
	| \qquad \verb’Expression "!=" Expression’		- оператор "XOR" (сложение по модулю 2)\\
	| \qquad \verb’"(" Expression ")"’
	| \qquad \verb’VarName "=" VarValue’ - атомарное утверждение для перечислимых переменных, соответствует выражению "значение переменной $VarName$ равно $VarValue$"\\

\verb’atom’ --- символьное слово\\


\subsection{Описание основных методов}
В процессе разработки программного продукта, реализующего синтез, были описаны следующие классы. Помимо названий классов, ниже описаны наиболее важные их методы:
\begin{itemize}
\item class Variable --- Класс, описывающий внешние и внутренние переменные модулей:\\
	  \verb’int* IDs’ --- возвращает указатель на массив номеров тех вершин BDD, которыми кодируется данная переменная. Для переменных типа $boolean$ длина массива равна 1, для переменных перечислимого типа, где количество возможных значений N, массив будет иметь длину $\log_2(N)$. Используется тип $int*$, так как при многие методы библиотеки $BuDDy$ используют именно такой тип аргументов.\\
	  \verb’int* NextIDs’ --- возвращает указатель на массив номеров тех вершин BDD, которыми кодируется данная переменная с оператором next(), то есть, штрихованная переменная.\\
	  \verb’unsigned GetVarBDDCnt’ --- возвращает количество вершин BDD, необходимых для описания данной переменной. Для переменной $boolean$ это одна вершина, для переменных перечислимого типа с N возможными значениями это $\log_2(N)$ вершин\\
	  \verb’bdd varValueBDD(std::string value)’ --- Используется при работе с переменными перечислимого типа. Возвращает BDD, соответствующее утверждению $var = value$.\\
	  \verb’bdd nextVarValueBDD(std::string value)’ --- Используется при работе с переменными перечислимого типа. Возвращает BDD, соответствующее утверждению $next(var = value)$.\\
	  \verb’std::string GetNameFromBDD_DOT(bdd fun)’ --- метод, сопоставляющий данному BDD строку - текстовое описание значения переменной. Если данная переменная имеет тип $boolean$, достаточно значения $var$ или $\overline{var}$. Если переменная имеет перечислимый тип, ее строковое представление имеет вид $v = val$.\\

\item SMVModule --- класс, описывающий конкретный модуль. В $GR-$игре речь идет о двух экземплярах класса - \verb’SMVModule env, SMVModule sys’\\
	  \verb’std::string GetName()’ --- метод, возвращающий имя данного модуля\\
	  \verb’bdd GetInitial()’ --- символьное описание начального состояния в виде BDD\\
	  \verb’bdd GetTransition()’ --- символьное описание правил переходов данного модуля в виде BDD. Описывает конечный автомат\\
	  \verb’std::vector<bdd> GetJustice()’ --- набор всех требований справедливости. Каждое требвание является булевой фромулой и представляется в виде BDD. Префикс $GF$ перед каждым требованием опускается.\\
	  \verb’Variable GetVariable(std::string varName)’ --- Получение элемента класса $Variable$ по ее строковому названию. Если переменной с таким именем не существует, \\
	  \verb’std::vector<Variable> GetInternalVariables()’ --- набор всех внутренних переменных модуля.\\
	  \verb’std::vector<int> GetVariablesIds()’ --- набор всех номеров вершин BDD, которые исользуются для описания всех внутренних переменных\\
	  \verb’std::vector<int> GetVariablesNextIds()’ --- набор всех номеров вершин BDD, которые исользуются для описания всех ...... внутренних переменных\\

\item GRGame --- класс, описывающий данную $GR$-игру.\\
	\verb’GRGame(SMVModule environment, SMVModule system)’ --- основной конструктор класса. Для создания элемента класса достаточно передать два элемента класса $SMVModule$: описание модулей среды и системы.\\
	  \verb’bdd WinningRegion()’ --- Вычисление выигрышного региона и выигрышных для системы стратегий.\\
	  \verb’bdd getConroller(bdd winreg)’ --- Синтез контроллера $GR$-игры. Готовый контроллер представляется в виде BDD. Аргументом принимается описание выигрышного региона в виде BDD.\\
	  \verb’void Minimize(bdd &trans)’ --- Минимизация контроллера $GR$-игры\\
	  \verb’void printDot(std::string fileName, bdd bddtrans)’ --- Печать синтезированного контроллера $bddtrans$ в файл $filename$. Описание контроллера имеет синтаксис и формат файла DOT (???)\\

\item FileText --- Класс, описывающий $smv$-файл\\
	  \verb’void removeExtraData()’ --- Очистка текста файла от комментариев и их разбиение на отдельные токены.\\
	  \verb’void readSMVModules()’ --- Создание элементов класса $SMVModule$ из файла.\\
	  \verb’std::vector<std::string> getModuleNames()’ --- Метод, возвращающий набор всех имен модулей, которые представлены в $smv$-файле.\\
	  \verb’SMVModule GetModule(std::string moduleName)’ --- Создание экземпляра класса $SMVModule$, описание которого было прочитано в $smv$-файле.\\

\end{itemize}

%Поток обработки входного файла.
\subsubsection{Описание основных команд для синтеза}
Ниже описаны основные команды, которые должны быть выполнены при синтезе контроллера: от чтения файла до вывода контроллера.
\begin{verbatim}
	FileText file("[filename].smv");
	file.readSMVModules();

	SMVModule sys(file.GetModule("sys"));
	SMVModule env(file.GetModule("env"));
	GRGame arbiter2(env, sys);

	bdd win_reg = arbiter2.WinningRegion();

	bdd jds = arbiter2.getConroller(win_reg);
	arbiter2.removeStuttering(jds);

	arbiter2.Minimize(jds);
%	arbiter2.removeStuttering(jds);
	arbiter2.printDot("[dotFile].dot", jds);
\end{verbatim}

\section{Реализация задачи с арбитром}
Рассмотрим задачу арбитра для протокола взаимного исключения.
Существует несколько (два и более) процессов--клиентов, запрашивающих доступ к разделяемому ресурсу. В произвольный момент времени клиенты могут отправлять запрос на пользование ресурсом. При этом, в каждый момент времени разделяемый ресурс может использоваться не более, чем одним клиентом. Представим формальное описание поведения клиентов (среды) и требуемого поведения арбитра (системы), а также требования справедливости

Формальное описание.

Допустим, в задаче речь идет об N клиентах. Каждый клиент в момент, когда у него появляется необходимость доступа к ресурсу, делает запрос на доступ. Для этого он устанавливает значение переменной $r_i = TRUE$. Арбитр управления доступом к ресурсу даёт разрешения на доступ к ресурсу, устанавливая значение переменной $g_i = TRUE$.

Запрос на доступ к ресурсу должен оставаться поднятым до тех пор, пока доступ не дадут. То есть, если запрос к ресурсу поднят, а доступ к нему в данный момент времени закрыт, то на следующем шаге запрос не будет опущен. Таким образом, требования к поведению среды описываются символьно как:
$\rho_e = \wedge_i ((r_i \wedge !q_i) \Rightarrow (next(r_i) = r_i))$ 

Система не может одновременно давать разрешение разным клиентам на доступ к разделяемому ресурсу. Если поднят запрос от некоторого клиента, и разрешение есть (!!!), то запрещать доступ на следующем шаге нельзя. Если запроса на данном шаге нет, то ..........
$\wedge_{i \not= j} ( (g_i' \wedge g_j') \wedge \wedge_i (r_i = g_i) \Rightarrow (g_i' = g_i) )$

Изначально, все флаги запросов на доступ к ресурсу и флаги разрешений доступа опущены:
$\wedge_i (\overline {r_i} \wedge \overline {q_i})$

%$X = \{r_i\ | i = 1, ..., n\}$ --- множестно переменных состояния, управляемых средой
%$Y = \{q_i\ | i = 1, ..., n\}$ --- множестно переменных состояния, управляемых системой
Синтезируемая совместная система должа удовлетворять условию сильной справедливости:
$\phi = \wedge_i (GF (r_i \wedge g_i) ) \Rightarrow \wedge_j GF (r_j = g_j)$
Условие сильной справедливости представляется в виде набора условий слабой справедливости, и разбивается на предположения: 
$\phi_e = \wedge_i GF (r_i \wedge g_i)$ и гарантии: $\phi_s = \wedge_j GF (r_j = g_j)$.

\subsubsection{Представление на языке SMV}
Перечисленные выше требования к арбитру протокола взаимного исключения можно представить на языке $SMV$. Ниже приведен пример требований для случая двух клиентов.

В примере представлены описания двух модулей~--- моделей среды и системы. У каждого модуля есть свои внутренние переменные, описаны их начальные значения. Правила $TRANS$ переходов модулей~--- это правила поведения $\rho_e$ и $\rho_s$, представленные на языке SMV. Предположения (как условия слабой справедливости среды) и гарантии (как условия слабой справедливости системы) описываются правилами JUSTICE.

\begin{verbatim}
MODULE main
  VAR
    e : env(s.g1, s.g2);
    s : sys(e.r1, e.r2);

MODULE env(g1, g2)
  VAR
    r1 : boolean;
    r2 : boolean;
  ASSIGN
    init(r1) := FALSE;
    init(r2) := FALSE;
  TRANS
    ((r1 & !g1) -> (r1 <-> next(r1))) &
    ((r2 & !g2) -> (r2 <-> next(r2)));
  JUSTICE
    !(r1 & g1);
    !(r2 & g2);

MODULE sys(r1, r2)
  VAR
    g1 : boolean;
    g2 : boolean;
  ASSIGN
    init(g1) := FALSE;
    init(g2) := FALSE;
  TRANS
    (!(r1 <-> g1) | (g1 <-> next(g1))) &
    (!(r2 <-> g2) | (g2 <-> next(g2))) &
    !(next(g1) & next(g2));
  JUSTICE
    r1 <-> g1;
    r2 <-> g2;
\end{verbatim}

\section{Результаты}
В следующей таблице приведено сравнение быстродействия, количества узлов ..........
!!!!! сказать ранее, что за JTLV!!!!
% Каждая таблица должна иметь номер и название, которые указываются над ней.
% Если в документе таблица одна, ее не нумеруют и слово ``таблица'' не пишут.  
% При переносе таблицы на другой лист в его правом верхнем углу пишут слово 
% ``Продолжение'' и номер таблицы, например,  ``Продолжение табл. 1.2''. 
% На все таблицы должны быть ссылки в тексте, например ``\ldots приведены в 
% табл. \ref{tTable}''. Если таблица не имеет номера, при ссылке слово 
% ``таблица'' пишут полностью. 
% 
Все вычисления производились на компьютере ..... Характеристики ПК:
Процесор Intel Core i5-2410M 2.30GHz
Объем оперативной памяти 4Gb.\\

\begin{Table}{Время синтеза контроллера для задачи арбитра с}{tTable}
\begin{tabular}{|c!{\setlength{\arrayrulewidth}{1pt}\vline}c|c|c|c|c|c|} \hline
\multirow{2}{*}{lines}  & \multirow{2}{*}{Переходы} & \multicolumn{2}{c|}{old}& \multicolumn{2}{c|} {new}& \multicolumn{1}{c|} {jtlv} \\\cline{3-7}
 	&	&	WinReg & Synthesis  & WinReg & Synthesis & WinReg\\ \hline
2	& 24	&	0.001	& 0.003		& 0.009	& 0.007    & 0.012	\\ \hline
3	& 540	&	0.01	& 0.007		& 0.032	& 0.013    & 0.021	\\ \hline
4	& 2348	&	0.4		& 0.02		& 0.058	& 0.020    & 0.057	\\ \hline
5	& 9762	&	1.4		& 0.074		& 0.109	& 0.039    & 0.235	\\ \hline
6	& 39038	&	3.6		& 0.19		& 0.193	& 0.078    & 1.759	\\ \hline
7	&151072	&	14.3	& 0.71		& 0.346	& 0.211    & 16.261	\\ \hline
8	&568888	&	51.5	& 2.74		& 0.668	& 0.507    & 121.15	\\ \hline
9	&2094290&	178.7	& 10.83		& 1.32	& 1.424    & ------	\\ \hline
10	& -----	& -----		& -----		& 3.22	& 3.396    & ------	\\ \hline
\end{tabular}
\end{Table}

Можно увидеть преимущества и недостатки минимизации: количество вершин в системе переходов, описывающей синтезируемый контроллер, уменьшается, как правило, более, чем в 2 раза.

При этом растет количество переменных BDD. Это обусловлено тем, что при минимизации возникает необходимость хранения дополнительной информации о номере стратегии $jx$. И из--за увеличения количества переменных увеличивается размер самих BDD, то есть, количество вершин.

По таблице видно, что рост размера системы переходов и времени выполнения ее синтеза происходит экспоненциальным образом. 
Однако, главный параметр, определяющий, насколько выполнены поставленные цели~--- это скорость роста времени синтеза относительно скорости роста размера синтезируемой системы.


\subsection{Минимизация BDD}
\subsubsection{Изменение порядка переменных}
Как показано в книге [Model Chacking, Karpov,Y.G.] (9.3, p. 208), размер BDD сильно зависит от предложенного порядка переменных.\\
На начальных этапах разработки программного средства был выбран следующий порядок переменных BDD:
\begin{enumerate}
	\item Все переменные среды: $env_1, env_2, ..., env_k$
	\item Все переменные системы: $sys_1, sys_2, ..., sys_l$
	\item Все штрихованные переменные среды: $env'_1, env'_2, ..., env'_k$
	\item Все штрихованные переменные системы: $sys'_1, sys'_2, ..., sys'_l$
	\item Переменная номера стратегии $jx$
	\item Штрихованная переменная номера стратегии $jx'$
\end{enumerate}
При этом выполнение многих операций, таких как ...(primeAllVariables) требовало перестроения дерева BDD, что требовало некоторого количества времени. Так как в работе мы имеем дело с символьным представлением систем переходов, то выполнение операции перехода Next к следующим состояниям происходит большое количество раз, чем значительно увеличивает общее время вычислений.

Однако, можно рассмотреть иной вариант порядка расположения переменных BDD.
\begin{enumerate}
	\item Первая переменная (неважно, среды или системы): $var_1$
	\item Первая штрихованная переменная: $var'_1$
	\item Вторая переменная (неважно, среды или системы): $var_1$
	\item Вторая штрихованная переменная: $var'_1$
	...................(и так далее)
	\item Переменная номера стратегии $jx$
	\item Штрихованная переменная номера стратегии $jx'$
\end{enumerate}
Данное расположение имеет существенное преимущество: при применении операции Next к BDD, состоящей из нештрихованных переменных, ....
С учетом данных замечаний о порядке переменных, на дальнейших этапах разработки программного средства работа с переменными была изменена так, чтобы 

\begin{Table}{Ускорение синтеза при изменении порядка переменных}{tTable}
\begin{tabular}{|c!{\setlength{\arrayrulewidth}{1pt}\vline}c|c|c|c|c|} \hline
\multirow{2}{*}{lines}  & \multirow{2}{*}{Переходы} & \multicolumn{2}{c|}{old}& \multicolumn{2}{c|} {new}\\\cline{3-6}
 	&	&	WinReg & Synthesis  & WinReg & Synthesis\\ \hline
2	& 24	&	0.001	& 0.003		& 0.009	& 0.007\\ \hline
3	& 540	&	0.01	& 0.007		& 0.032	& 0.013\\ \hline
4	& 2348	&	0.4		& 0.02		& 0.058	& 0.020\\ \hline
5	& 9762	&	1.4		& 0.074		& 0.109	& 0.039\\ \hline
6	& 39038	&	3.6		& 0.19		& 0.193	& 0.078\\ \hline
7	&151072	&	14.3	& 0.71		& 0.346	& 0.211\\ \hline
8	&568888	&	51.5	& 2.74		& 0.668	& 0.507\\ \hline
9	&2094290&	178.7	& 10.83		& 1.32	& 1.424\\ \hline
10	& -----	& -----		& -----		& 3.22	& 3.396\\ \hline
\end{tabular}
\end{Table}

\subsubsection{Удаление недостижимых переходов}
Правила переходов синтезированного контроллера, как правило, содержут большое количество недостижимых переходов.
При минимизации размера контроллера, помимо "сворачивания" состояний, различающихся лишь номером $jx$-стратегии, можно также удалять неиспользуемые переходы. Переходы системы, не достижимые из начального состояния, после минимизации также не будут достижимы. Поэтому их можно удалить до минимизации.

\begin{verbatim}
jds = arbiter2.GetAllReachableTrans(jds);
\end{verbatim}

Замечание.
Однако, после минимизации контроллера могут возникнуть новые недостижимые состояния и переходы. Поэтому после применения метода minimize() необходимо их повторное удаление.

Ниже представлено сравнение времени минимизации полной системы переходов со временем, требуемым для удаления недостижимых состояний системы и последующей минимизации системы, состоящей только из достижимых состояний.
\begin{Table}{Выигрыш при минимизации}{tTable}
\begin{tabular}{|c!{\setlength{\arrayrulewidth}{1pt}\vline}c|c|c} \hline
lines & before & later \\ \hline
2  & 0.003	& 0.004	\\ \hline
3  & 0.007  & 0.007	\\ \hline
4  & 0.017  & 0.014	\\ \hline
5  & 0.030  & 0.021	\\ \hline
6  & 0.076  & 0.049	\\ \hline
7  & 0.220  & 0.075	\\ \hline
8  & 0.661  & 0.184	\\ \hline
9  & 2.099  & 0.381	\\ \hline
10 & 6.4  & 1.042	\\ \hline
\end{tabular}
\end{Table}



%%%%%%%%%%
\chapter{Реализация синтеза систем переходов из расширенного класса GR--формул}

\section{Расширение GR}
Преобразования требований, чтобы привести их к виду GR.

\section{Реализация задачи AHBA}
Описание задачи на естественном языке.

Описание задачи на формальном языке.

Представление на SMV?


\section{Результаты}
Быстродействие, количество узлов

Сравнение с JTLV




%%%%%%%%%%
\Chapter{Заключение}


%%%%%
\chapter{Основные определения и постановка задачи}
\label{cReview}
% Рекомендуемый объем главы "--- 10--15 стр. 
% Название главы должно отражать ее содержание, например ``Проблема вечного 
% двигателя''.
% \section{ Общественная/научная потребность решения задачи}
% \section{ Текущее состояние проблемы в России и за рубежом}
% Раздел содержит обзор литературы по теме работы
% \section{Объект и методы исследования}
% Описание реального объекта исследования, используемых методов исследования,
% техническое и организационное  содержание работ.
% 
% \section{    Уточненные требования к работе }
% Окончательная постановка задачи с явным отсечением лишнего 
% (чужого, нереализуемого и т.д.)


\section{Реагирующие системы}
Необходимость параграфа:

Речь о синтезе идет касаемо именно реагирующих систем - нас интересует их поведение при взаимодействии с внешней средой.
Требования предъявляются к таким системам, и целью работы является синтез контроллера \textbf{реагирующей} системы, удовлетворяющей заданным требованиям.

Должно быть введено определение реагирующей системы, сказано о действиях среды и системы, порядке их взаимодействия.

\section{Линейная темпоральная логика}
Формулы, с помощью которых представляются требования, относятся к классу LTL.
Описать, почему нужны именно формулы LTL (важна привязка к времени, возможность описать большой класс требований). Дать формальное определение.

Описание формата $GR(1)$. Описать преимущество использования именно формул из подкласса LTL.

\section{Представление систем переходов}
\subsection{Символьное представление}
Цель - ввести описание символьного представления систем переходов.
Правила поведения среды и системы удобно описывать в символьном виде.

Сказать про удвоение количества переменных, описывающих систему: $x'$ или $next(x)$.

Итог - представление конечного автомата в виде булевой функции.

\subsection{Представление с помощью BDD}
Любые булевы функции удобно представлять в виде BDD.

Следствие - системы переходов (конечные автоматы и автоматы Бюхи) можно представлять в виде BDD.

Описать преимущества.

Описать программное представление BDD: BuDDy~\cite{LindNielsen2002}.

Итог - удобное программное представление систем переходов с возможностью простого программно и быстрого по времени изменения правил переходов.

\section{Just Discrete System}
Необходимо ввести определение JDS для того чтобы через них описать понятие реализуемости. Также целью синтеза является именно получение JDS по описанным требованиям.

Можно не вводить понятие Fair Discrete System, так как FDS не используются в работе, а используются лишь fairness-free FDS, которые как раз и являются по определению JDS.

$FDS\ D(V, \theta, \rho)$ удовлетворяет требованию $\phi$, или, $D |= \phi$, если .....

\section{Реализуемость требований}
Цель - ввести понятие реализуемости требований. Необходимо для использовании в постановке задачи.

Формальное определение:
Требования $\phi \in LTL$ реализуемы, если существует $FDS\ D(V, \theta, \rho)$ такой, что $D |= \phi$.

Просто на словах, неформальное определение: Существует ли поведение системы, удовлетворяющее предъявленным LTL-требованиям, что для любых допустимых действий среды система сможет действовать таким образом, чтобы у их совместного поведения выполнялись условия справедливости.

Объяснить, что таких поведений может быть несколько.
Объяснить, что они могут выполняться/не выполняться в разных состояниях.

\section{Постановка задачи}
Так как основные понятия, необходимые для конкретизации постановки задачи, определены, то уже на данном этапе можно дать строгие требования к задаче, которая здесь решается.
Кратко: на входе задачи имеем:
\begin{itemize}
\item описание поведения среды (с оператором X=next)
\item требования, которым должно удовлетворять поведение системы (с оператором X=next)
\item условия справедливости $\phi_{GR1}$: требования к взаимодействию среды и системы в формате $GR(1)$
\item описание начальных состояний среды и системы
\end{itemize}

Для предъявляемых выше требований необходимо проверить их реализуемость. (т.е. существует ли FDS-контроллер .....)

Если требования реализуемы из начальных состояний среды и системы, необходимо построить контроллер $D(V = X \cup Y, \theta, \rho_{es})$ - совместную модель поведения среды и системы, которая будет удовлетворять предъявленным требованиям поведения и справедливости: $D |= \phi_{GR1}$.

После построения контроллер должен транслироваться в формат, удобный для визуального представления его поведения.








%%%%%
\chapter{Проверка реализуемости}
\label{cDesign}
% Рекомендуемый объем главы --- 10--25 стр.
% Название главы должно отражать ее содержание, например ``Построение вечного двигателя на основе технологий объектно-ориентированного программирования''.
% Глава должна содержать
% структурированное описание использованного метода, подхода, математического аппарата, 
% разработанного алгоритма; обоснование решений, доказательство утверждений, 
% аналитические оценки. Основное содержание теоретической части должны 
% составлять результаты, полученные автором. При необходимости, описание 
% используемых классических методов должно быть приведено в главе  \ref{cReview}.
\section{Симуляционная игра}
Цель параграфа - формализация взаимодействия среды и системы.

Симуляционная игра формально описывает взаимодействие среды и системы.

Реализуемость формулы будет сводиться к поиску победителя в симуляционной игре между двумя игроками - средой и системой. 

Симуляционной игрой называется набор $G : (V, X, Y, \theta, \rho_e, \rho_s, \phi)$, где: .....

Описать, кто когда ходит, какие цели, условия выигрыша среды/системы.

\section{Мю-исчисление}
Формулы $\mu$-исчисления необходимы при вычислении выигрышного региона: там идет работа с множествами состояний. А множества состояний можно удобно представлять в виде формул $\mu$-исчисления; также легко определить все необходимые операции над множествами состояний.

Ввести понятие $\mu-$исчисления: множество состояний, в которых верна данная LTL-формула. 

Описать, как определяются все операции: $\lnot$, $\lor$, $\wedge$.
Дать определение и пояснить смысл функции cox(step); пояснить смысл GreatestFixPoint и LeastFixPoint.

\section{Вычисление выигрышных регионов}
Описать алгоритм вычисления выигрышных регионов.

Пояснить, что также происходит вычисление выигрышной для системы стратегии.

Описать, за что отвечает каждый fixPoint.

\subsection{Проверка реализуемости}
Описать, как из выигрышного региона понимаем, реализуема ли формула $\phi$.

Итог - полное описание процесса проверки реализуемости GR(1)-формулы засчет вычисления выигрышного региона и сравнения с начальными состояниями среды и системы.





%%%%%%
\chapter{Синтез}
\label{cImplementation}
% Рекомендуемый объем главы --- 10-30 стр.
% Название главы должно отражать ее содержание, например ``Архитектура вечного двигателя''.
% В главе должно быть описание этапов разработки технического решения задачи. Следующий пример
% приведен для работ, связанных  с проектированием и реализацией 
% программного продукта.
% \section{Архитектура системы}
% Псевдокоды или блок-схемы основных алгоритмов, основные структуры данных  и др.
% \section{Интерфейс системы}
% \label{sSpec}
% Интерфейс пользователя, модульная структура, API
% \section{Особенности реализации}
% Использованные инструментальные средства, приемы программирования, 
% технические решения, связанные с ограничениями аппаратных или программных 
% средств.
\section{Синтез}
Описать, как определяется и в чем смысл у $\rho_1, \rho_2, \rho_3$.

Доказать, что система детерминирована.

\section{Минимизация системы}
Проблема при синтезе - в итоговой JDS много лишних состояний.

Описать алгоритм минимизации - удаления похожих состояний.

Замечание. При этом увеличивается количество переменных BDD.

\subsection{Результаты минимизации}
Привести таблицу сравнения размеров JDS-контроллера, количества переменных BDD и количества вершин BDD до и после минимизации.

Результат - представлен основной алгоритм.




%%%%%  
\chapter{Чтение и вывод }
\label{cExperiments}
% Рекомендуемый объем главы --- 5--20 стр.
% Название главы должно отражать ее содержание, например ``Оценка эффективности вечного двигателя''.
% \section{Тестирование и испытание метода или программы}
% Проверка адекватности модели, сравнение с существующими аналогами, выбор 
% представительного множества тестов, анализ результатов испытаний.
% \section{Примеры применения метода или программы}
Необходимо добавить оболочку алгоритма - чтение из файла удобного формата и вывод в удобный для проверки и изучения контроллера формат.


\section{Задание симуляционной игры с помощью формул LTL}
Цель - перевести представление симулящионной игры в более удобное и понятное. Разделить GR(1) требования на импликацию $Assumptions => Guarantees$.

Получить две системы с условиями справедливости.

Таким образом, можно представлять два SMV-модуля отдельно с условиями справедливости, а при вычислении выигрышных регионов рассматривать $\bigwedge_i {GF J_i^e}-> \bigwedge_j {GF J_j^s}$
%$$(\phi_i^e \wedge G\rho_e \wedge .... ) -> (\phi_j^s \wedge \rho_s \wedge \bigwedge_{j in ..} {GF J_j^s})$$

\subsection{Исользование языка SMV для описания начальных данных}
Необходим синтаксис для удобного описания начальных данных: переменных, начальных состояний и правил переходов - для среды и системы. А также для описания GR(1) требований к поведению контроллера.
Поэтому описываем все начальные данные в виде модулей smv
?сказать о том, как разбить GR(1) на assumptions and guarantees.

Описать используемый синтаксис языка SMV: 
\begin{itemize}
\item module main;
\item boolean and enumerable types;
\item VAR, ASSIGN, TRANS, JUSTICE
\end{itemize}

\section{Трансляция синтезированной системы в DOT-файл}
Для удобной работой с полученным контроллером (в дальнейшем) нужна его визуализация: необходимо транслировать его в программу, строящую изображение системы переходов.

Результат - вкупе с предыдущими главами описаны все этапы синтеза с обоснованиями корректности:
по smv-файлу, описывающему поведение среды и системы, а также требованиям к контроллеру, получаем контроллер, представленный программно и визуально.



%%%%%%%%%
\chapter{Задача арбитра}
Описание задачи контроллера взаимного исключения при совместном доступе к разделяемому объекту (арбитр нескольких линий):
\begin{itemize}
\item постановка задачи
\item действия среды
\item действия системы
\item требования к контроллеру
\end{itemize}


\section{Решение задачи арбитра с использованием BuDDy и c++}
Необходимо представить входные данные и результат:

Вставить описание задачи арбитра взаимного исключения на языке smv.

Вставить граф - визуализацию контроллера.

\section{Проблема порядка переменных}
Описание проблемы, с которой столкнулся я сам.
Если расположить переменные как:
\begin{itemize}
\item все sys
\item все env
\item все next(sys)
\item все next(env)
\end{itemize}
То время выполнения будет расти экспоненциально из-за роста BDD.

Но можно расположить иначе:
        Для каждой переменной системы и среды сделать порядок\\ 
                i - var from {env, sys}\\
                i+1 - next(var)


\section{Решение задачи арбитра с использованием JTLV}
\subsection{Про JTLV}
Описать, зачем JTLV.

Описать, как пользоваться - пример с вычислением выигрышного региона.

\section{Сравнение}
Таблица, сравнивающая два вида программ на c++, мою программу на jtlv и из статьи Питермана:
\begin{itemize}
\item время вычисления выигрышного региона
\item время на синтез (только c++)
\item время на минимизацию
\end{itemize}



%%%%%%
\chapter{Решение задачи арбитра для AHB}
(возможно, глава будет удалена)

\section{Постановка задачи и описание шины}

\section{SMV}
Описать smv-спецификацию, подаваемую на вход в c++ и jtlv~\cite{jtlv2018}.
\section{Сравнение}
Сделать график сравнения.
\section{Замечания по требованиям к арбитру для AHB}
Описать неполноту требований.
\cite{amba2018,ambaRM2018}







%%%%%%
\Chapter{Заключение }
% Рекомендуемый объем --- 2--4 стр.
% Содержит изложение итогов квалификационной работы в сопоставлении с общей 
% целью и поставленными задачами. Формулировка суждения автора о научной 
% новизне и практической ценности ВКР. Предложения по внедрению результатов, % перспективы продолжения работы 

\begin{itemize}
\item Описан парсер с языка SMV
\item Реализовано вычисление выигрышных регионов
\item Реализован синтез контроллера
\item Произведена трансляция контроллера в читаемый и визуально понятный вид
\item Рассмотрены примеры задач, для которых может потребоваться синтез контроллера
\end{itemize}

Сравнение с результатами вычислений в статье Питермана~\cite{Piterman2006}: выяснилось, что описанная в статье синтезированная система переходов содержит ошибки.

Сравнение времени синтеза для задачи арбитра:
\begin{itemize}
\item в статье Питермана
\item с использованием JTLV
\item на c++
\end{itemize}





%%%%%
\bibliographystyle{gost71s}
\bibliography{bibliography}                              





%%%%%%
\appendix
\chapter{Визуализация контроллера - арбитра для 2 линий}

\chapter{Приложение 2: Программа, реализующая синтез, на языке C++}
(?!) - надо ли прикладывать?
Или необходимо лишь выложить список описанных классов и методов?


%%%%%%
\chapter{Приложение 3: Программа SMV, описывающая модель задачи арбитра для двух линий}


%%%%%%
\chapter{Приложение 4: Программа SMV, описывающая модель AHB}


$FDS\ D: (V, \theta, \rho)$
Требования слабой справедливости $J_i \in J$ описывают те условия, которые должны выполняться в FDS бесконечно часто. Формально их можно представить на языке формул линейной темпоральной логики как $\bigwedge_{i=1..m} G J_i$.

Требования сильной справедливости $(p_i, q_i) \in C$ представляют собой пару утверждений, таких что должно выполняться условие: если на данной FDS бесконечно часто истинно утверждение $p_i$, то должно бесконечно часто выполняться утверждение $q_i$. Формально такие требования представляются на языке LTL-формул как $$\bigwedge_{1 \le i \le m} (GF p_i \Rightarrow GF q_i)$$



% \label{cHints}
% \section{Основные принципы}
% \subsection{Характеристика выпускной квалификационной работы магистра}
% Магистерская диссертация представляет собой самостоятельную и логически 
% завершенную  научно-техническую разработку,  связанную  с 
% решением задачи одного из следующих видов: проектно-конструкторской, 
% производственно-технологической, организационно-управленческой или 
% научно-учебной.  Выпускная работа магистра должна демонстрировать 
% актуальность, новизну, научную ценность и практическую значимость работы 
% соискателя степени.
% 
% Тематика выпускных квалификационных работ должна быть направлена на 
% решение профессиональной задачи в области НИР и ОКР кафедры распределенных 
% вычислений и компьютерных сетей: математическое моделирование, теория 
% информации, теория кодирования, верификация программных систем, технология 
% проектирования программного обеспечения, теория и практика разработки 
% компьютерных сетей. При согласовании с заведующим кафедрой допускается 
% тематика из смежных разделов теоретической информатики, прикладной 
% математики и информационных технологий.
% 
% При выполнении выпускной квалификационной работы студент должен: 
% \begin{itemize}
% \item    показать свою способность и умение, опираясь на полученные 
% углубленные знания, умения и сформированные общекультурные и 
% профессиональные компетенции, самостоятельно решать научные и прикладные 
% задачи в области теоретической информатики, прикладной математики и 
% информационных технологий на современном научном и техническом уровне,  
% \item       профессионально излагать специальную информацию, научно 
% аргументировать и защищать свою точку зрения. 
% \end{itemize}
% \subsection{Требования к оформлению выпускной квалификационной работы}
% Рукописи выпускных квалификационных работ следует оформлять по правилам, 
% установленным государственным стандартом для оформления научно-технической 
% документации, научных статей и отчетов. Они введены различными статьями 
% ГОСТ и системой СИБИД — стандартов по информации, библиотечному и 
% издательскому делу. Основной документ: «ГОСТ 7.32-91 (ИСО 5966-82). Отчет 
% о научно-исследовательской работе. Структура и правила оформления». 
% При подготовке рукописи необходимо следовать руководству по оформлению 
% студенческих выпускных работ и отчетов СПбГПУ \cite{thesisrules2000}.  Особое внимание 
% следует обратить на недопустмость появления полупустых страниц в середине 
% глав в результате автоматического разбиения текста на страницы.  
% 
% Минимальный объем выпускной работы магистра в формате А5 должен составлять 
% 70 страниц без учета приложений и списка литературы.  
% Рукописи выпускных квалификационных работ следует готовить на компьютере, 
% распечатывать на принтере и оформлять брошюрой в мягком переплете.  
% \section{Исполнение текста}
% \subsection{Использование \LaTeX}
% Для оформления работы рекомендуется использовать издательскую систему \LaTeX.
% {\color{red}
% Для получения корректного pdf-файла работы необходимо сделать следующее:
% \begin{enumerate}
% \item Установить дистрибутив MikTeX (для платформы Windows).
% \item Установить пакет cm-super средствами администратора пакетов MiKTeX.
% \item Для компиляции работы использовать пакетный файл make.bat, прилагаемый к дистрибутиву spbstuthesis. 
% \end{enumerate}
% }
% 
% \subsection{Формулы}
% Формулы следует набирать исключительно в математическом режиме \LaTeX или MS Word. 
% Всегда после первого появления в формулах новых переменных необходимо 
% объяснить их смысл в той же последовательности, в какой они даны в 
% формуле, как это показано в нижеприведенных примерах. 
% Небольшие или малосущественные формулы, такие как $S=ab$, где $a$ и $b$ --- стороны прямоугольника,
%  следует оформлять 
% как строчные, в то время как громоздкие или значимые для понимания работы 
% формулы следует оформлять как выключные. Формулы должны быть логически встроены в 
% окружающий их текст. Для этих целей можно использовать подходящие вводные 
% слова:
% 
% \ldots Из приведенных преобразований следует, что логарифмическое 
% отношение правдоподобия для $k$-го информационного символа может быть 
% выражено как 
% \begin{equation*}
% L(x_k)=\ln \frac{\sum_{(s',s)\in 
% S_1}\alpha_{k-1}'(s')\gamma_k(s',s)\beta_k'(s)}{\sum_{(s',s)\in 
% S_0}\alpha_{k-1}'(s')\gamma_k(s',s)\beta_k'(s)},
% \end{equation*}
% где $S_0$ и $S_1$ --- множества переходов решетки, соответствующих 
% нулевому и единичному значениям информационного символа, $ \gamma_k(s',s)$ 
% --- функция правдоподобия для перехода из состояния $s'$ в $s$. Отсюда 
% видно, что \ldots
% 
% 
% В тех и только в тех случаях, когда на формулу необходимо сослаться, ее 
% следует нумеровать.
% \begin{equation}
% \label{mBCJRAlpha}
% \alpha_{k}'(s)=\frac{\sum_{\tilde s\in S}\alpha_{k-1}'(\tilde s)\gamma_k(\tilde s,s)}{\sum_{s'\in S}\sum_{\tilde s\in S}\alpha_{k-1}'(\tilde s)\gamma_k(\tilde s,s')}.
% \end{equation}
% При этом ссылку на формулу следует оформлять как \eqref{mBCJRAlpha}. 
% 
% В случае необходимости оформления нескольких тесно связаннаых уравнений 
% (например, системы уравнений), их следует группировать:
% \begin{eqnarray*}
% a_1&=&x_1+x_2\\
% a_2&=&x_1-x_2.
% \end{eqnarray*}
% Перенос длинной формулы на другую строку делают после математических 
% знаков, которые обязательно повторяют на новой строке:
% \begin{eqnarray}
% P_{\text{$M$-АМ}}&=&\displaystyle\frac{M-1}{M}P\left\{\left|\eta\right|>d\sqrt{\frac{E_g}{2}}\right\}=\frac{M-1}{M}\frac{2}{\sqrt{\pi 
% N_0}}\int_{d\sqrt{\frac{E_g}{2}}}^{\infty}e^{-\frac{x^2}{N_0}}dx=\nonumber\\
% &=&\displaystyle 
% \frac{M-1}{M}\frac{2}{\sqrt{2\pi}}\int_{\sqrt{\frac{d^2E_g}{N_0}}}^{\infty}e^{-\frac{x^2}{2}}dx=\frac{2M-2}{M}Q\left(\sqrt{\frac{d^2E_g}{N_0}}\right). 
% \label{mPMAM}
% \end{eqnarray}                                                         
% При написании формул применяют обычные знаки препинания, например, 
% разделяют запятыми несколько формул, написанных подряд, или ставят точку, 
% если формулой заканчивается предложение.
% \subsection{Ссылки}
% При подготовке текста диссертации следует избегать повторов. При необходимости 
% следует ссылаться на те элементы работы (разделы, формулы, таблицы, рисунки), в которых 
% соответствующий материал 
% уже был представлен. Вместе с тем, в некоторых случаях для упрощения 
% понимания содержания может быть полезно кратко (в пределах одного
% предложения) напомнить читателю соответствующие факты, например: ``Напомним,
% что в разделе \ref{sSpec} на основе закона сохранения энергии была 
% показана невозможность создания вечного двигателя''. 
% 
% \subsection{Таблицы}
% Каждая таблица должна иметь номер и название, которые указываются над ней.
% Если в документе таблица одна, ее не нумеруют и слово ``таблица'' не пишут.  
% При переносе таблицы на другой лист в его правом верхнем углу пишут слово 
% ``Продолжение'' и номер таблицы, например,  ``Продолжение табл. 1.2''. 
% На все таблицы должны быть ссылки в тексте, например ``\ldots приведены в 
% табл. \ref{tTable}''. Если таблица не имеет номера, при ссылке слово 
% ``таблица'' пишут полностью. 
% 
% \begin{Table}{Время декодирования, с}{tTable}
% \begin{tabular}{|c!{\setlength{\arrayrulewidth}{1pt}\vline}c|c|c|c|c|c|} \hline
% \multirow{2}{*}{$E_b/N_0$, дБ}   &\multicolumn{2}{c|}{$\max M_{i,j} = 3$}& \multicolumn{2}{c|} {$\max M_{i,j} = 6$}& \multicolumn{2}{c|} {$\max M_{i,j} = 9$} \\\cline{2-7}
%  & Гибр. & Итер.     & Гибр.      & Итер. & Гибр.& Итер.\\ \hline
% 4.8  & 0.0014    & 0.0050    & 0.0194    & 0.0419    & 0.0695    & 0.2009               \\ \hline
% 5.0  & 0.0016    & 0.0056    & 0.0183    & 0.0450    & 0.0732    & 0.2166               \\ \hline
% 5.2  & 0.0017    & 0.0059    & 0.0165    & 0.0471    & 0.0770    & 0.2141               \\ \hline
% 5.4  & 0.0018    & 0.0064    & 0.0145    & 0.0473    & 0.0830    & 0.2167               \\ \hline
% 5.6  & 0.0021    & 0.0066    & 0.0135    & 0.0492    & 0.0860    & 0.2237                 \\ \hline
% \end{tabular}
% \end{Table}
% 
% Таблицу размещают после первого упоминания в тексте так, чтобы ее было 
% удобно читать без поворота страницы или с поворотом по часовой 
% стрелке. 
% 
% Основное поле таблицы  содержит строки (горизонтальные ряды) и графы 
% (колонки). Заголовки строк образуют боковик. В верхней части таблицы размещают головку (заголовок боковика), заголовки граф и подзаголовки граф.
% Заголовки строк и граф начинают с прописной буквы, подзаголовки --- со 
% строчных букв, если они составляют одно предложение с заголовком, и с 
% прописных букв, если они самостоятельны. 
% 
% 
% 
% Если все физические величины, приведенные в таблице, выражены в одних и 
% тех же единицах, то обозначение единицы помещают в заголовке через 
% запятую, например: ``Размеры изделий, мм''. Обозначение единицы физической 
% величины, общей для всех данных в строке или графе, указывают в 
% соответствующей строке боковика или в заголовке графы. 
% Не допускается делить заголовки таблицы по диагонали и включать графу ``Номер по порядку''.
% 
% 
% \subsection{Рисунки}
% Как правило, учебные тексты иллюстрируют графиками, диаграммами, алгоритмами, схемами, 
% чертежами, фотографиями. Все иллюстрации в работе называют рисунками. 
% Каждый рисунок должен иметь номер  и название, которые размещаются под 
% ним. Если в работе содержится только один рисунок, то его не нумеруют.  
% 
% На каждый рисунок должна быть ссылка в тексте, например ``\ldots приведено на 
% рис. \ref{fMultiFigure}'', или ``\ldots составим схему замещения (рис. \ref{fSubfigure})''. 
% При повторной ссылке на одну и ту же иллюстрацию указывают сокращенно 
% слово ``смотри'', например: (см. рис. \ref{fMultiFigure}). 
% \begin{Figure}{Пример оформления рисунка}{fMultiFigure}
% \subfigure[Формат EPS\label{fSubfigure}]{\includegraphics[width=0.3\textwidth]{QAM4.eps}}
% %\subfigure[Формат PNG \label{fPNG}]{\scalebox{0.3}{\includegraphics[bb=0 0 278 374]{GVSM.png}}}
% \end{Figure}
% Рисунки могут быть расположены по тексту документа после первой ссылки на 
% них или размещены на отдельных листах так, чтобы их было удобно 
% рассматривать без поворота страницы или с поворотом по часовой стрелке. 
% 
% Графики, выражающие качественные зависимости, изображают в прямоугольных 
% координатах на плоскости, ограниченной осями координат без шкал значений 
% величины. Оси координат заканчивают стрелками, указывающими направление 
% возрастания значений величин (рис. \ref{fQualCurve}). Независимую переменную 
% откладывают по горизонтальной оси (ось абсцисс). В полярной системе 
% координат начало отсчета углов должно находиться на горизонтальной или 
% вертикальной оси. 
% \begin{Figure}{Качественная зависимость}{fQualCurve}
% \includegraphics[width=0.75\textwidth]{curve.eps}
% \end{Figure}
% 
% На графиках, выражающих количественные зависимости (экспериментальные или 
% расчетные), должна быть координатная сетка (рис. \ref{fPlot}).  Цифры располагают 
% ниже оси абсцисс и левее оси ординат, единицы  
% измерения физических величин указывают на одной линии с цифрами. 
% Значения переменных откладывают в линейном или логарифмическом масштабах. 
%  
% Переменные следует обозначать символом (см. рис. \ref{fQualCurve}), 
% математическим выражением (см. рис. \ref{fPlot}) или словами. Последний 
% вариант применяют, если переменная фигурирует один раз и введение 
% для нее специального обозначения нецелесообразно. 
% На одной координатной сетке допустимо изображать несколько (не более 6) 
% функциональных зависимостей, выделяя их линиями и точками разных типов. 
% В этом случае на графике обязательно должна присутствовать легенда, 
% позволяющая однозначно сопоставить представленные кривые 
% с рассматриваемыми в работе сущностями. Необходимо исключить наложение 
% легенды на линии зависимостей. Характерные точки диаграмм допускается отмечать графически, 
% например, кружками, крестиками и т. п.  Для построения графиков 
% рекомендуется использовать пакеты Gnuplot  или Matlab.
% 
% \begin{Figure}{Количественная зависимость}{fPlot}
% %\psfrag{erfc}[cr]{\tiny формула  \eqref{mPMAM}}
% %\psfrag{FER}[cc]{Вероятность ошибки $P_\phi$}
% \includegraphics[width=\textwidth]{GCC.eps}
% \end{Figure}
% 
% 
% При использовании цветных рисунков необходимо обращать внимание на 
% качество их воспроизведения при черно-белой печати. Необходимо также 
% избегать использования мелких шрифтов на рисунках.
% 
% Рекомендуется подготавливать графические материалы в векторном формате 
% EPS. Он позволяет осуществлять масштабирование рисунка без потери качества 
% (см. рис. \ref{fSubfigure}, \ref{fQualCurve}). 
% %, а также осуществлять манипуляции с текстом, как показано на рис. \ref{fPlot}. 
% Для подготовки 
% рисунков в этом формате можно воспользоваться свободно распространяемыми 
% пакетами  PDFCreator и OLETeX.  Пакет Gnuplot, предназначенный для 
% построения графиков, также позволяет генерировать файлы в формате EPS.
% При использовании рисунков в формате EPS необходимо сначала скомпилировать 
% исходный текст в формат DVI, используя latex.exe. Если в документе 
% использется пакет psfrag, предназначенный для манипуляций с текстом на 
% рисунках, далее необходимо воспользоваться командой dvips для 
% преобразования dvi-файла в ps-файл, после чего воспользоваться пакетом 
% Ghostscript для преобразования ps-файла в pdf-файл. Если psfrag не 
% используется, можно преобразовать dvi-файл в формат pdf напрямую с помощью 
% команды dvipdfm.  Данные преобразования следует выполнять только на 
% заключительном этапе работы над документом, т.к. существующие дистрибутивы 
% системы \LaTeX имеют эффективные инструменты предварительного просмотра.
% Существует также возможность включения графики в растровых форматах 
% (например, PNG, как показано на рис. \ref{fPNG}). Однако это требует 
% явного указания размера изображения, не позволяет осуществлять
% манипуляции с текстом на рисунке и приводит к громоздким конструкциям.
% 
% При использовании pdflatex использование графики в растровом формате 
% сильно упрощается, однако при этом становится невозможным использование 
% пакета psfrag и графики в формате EPS. Кроме того, каждый цикл компиляции документа требует 
% закрытия программы просмотра файла (например, Adobe Acrobat).
% \subsection{Библиография}
% При использовании материалов других работ необходимо указывать источник 
% заимствования \cite{mori2009performance,mori2009performanceof,Combinatorics}. 
% Заимствование материала без указания источника является плагиатом и 
% представляет собой основание для снятия работы с защиты. Библиографический 
% список должен включать в себя не менее 5 печатных работ. Не допускается 
% включение в него публикаций, на которые нет ссылок в тексте работы.
% 
% В ходе написания работы рекомендуется формировать библиографическую базу 
% данных в формате BiBTeX по предметной области и использовать ее для 
% автоматического формирования списка литературы.
% Для корректного его форматирования необходимо после однократной компиляции 
% документа с помощью latex.exe выполнить команду 
% \begin{verbatim}
% bibtex8 -c cp1251 -H thesis.aux
% \end{verbatim}
% Здесь cp1251 --- наименование кодировки, в которой сохранена база BiBTeX, 
% thesis.aux --- вспомогательный файл, сформированный latex. 
% Затем необходимо еще несколько раз откомпилировать документ для получения 
% правильных номеров ссылок.
% \subsection{Использование пакета spbstuthesis}
% Пакте spbstuthesis разработан на кафедре РВКС ФТК и предназначен 
% для оформления отчетов по НИР, бакалаврских, магистерских и конкурсных 
% работ.  Пакет загружается с опциями a5paper или a4paper в зависимости от 
% предполагаемого формата бумаги, на котором будет распечатана работа. 
% 
% В зависимости от типа документа преамбула должна содержать одну из 
% следующих команд:
% \begin{enumerate}
% \item Отчет по НИР: \begin{verbatim}
% \sciencereport{Тема работы}{№ группы}{студент}
%               {ученая степень, звание}{руководитель} 
% \end{verbatim}
% \item Бакалаврская работа:
% \begin{verbatim}
% \bachelor{Тема работы}{номер и название направления}
%           {№ группы}{студент}{ученая степень, звание}
%           {руководитель} 
% \end{verbatim}
% \item Дипломный проект специалиста:
% \begin{verbatim}
% \engineer{Тема работы}{номер и название направления}
%         {номер и название специальности}{№ группы}{студент}
%         {ученая степень, звание}{руководитель} 
% \end{verbatim}
% \item Магистерская работа:
% \begin{verbatim}
% \masters{Тема работы}{номер и название направления}
%         {номер и название программы}{№ группы}{студент}
%         {ученая степень, звание}{руководитель} 
% \end{verbatim}
% \item Работа, представляемая на конкурс Минобразования:
% \begin{verbatim}
% \ministrycontest{Девиз}{Название работы}
% \end{verbatim}
% \end{enumerate}
% Далее должны быть представлены аннотация работы на русском и английском 
% языках:
% \begin{verbatim}
% \Abstract{Аннотация по-русски}{Abstract in English}
% \end{verbatim}
% В начале документа рекомендуется указать директиву \verb.\sloppy.,
% которая осуществляет более агрессивный перенос слов, не допуская их выхода 
% на поля.  Оформление титульной страницы производится с помощью команды 
% \verb. \maketitle..  Далее для неконкурсных работ должно быть 
%  приведено задание, которое оформляется следующим образом:
% \begin{verbatim}
% \task{ФИО студента в дательном падеже}{
%\item Срок сдачи работы.
%\item Исходные данные к проекту (работе).
%\item Содержание расчетно-пояснительной записки (перечень подлежащих разработке вопросов).
%\item Перечень графического материала с точным указанием обязательных чертежей.
%\item Консультанты по проекту (с указанием относящегося к ним разделов проекта, работы).
%}
%\end{verbatim}
%Для квалификационных и конкурсных работ далее должна быть сгенерирована 
%аннотация с помощью команды \verb.\makeabstract..

Обязательным элементом документа является оглавление. После него 
рекомендуется привести список обозначений и сокращений.  Для оформления 
заголовков разделов, не подлежащих нумерации (введение, заключение, список 
обозначений и т.п.), следует использовать команду  \verb.\Chapter..
Для оформления рисунков и таблиц следует использовать окружения 
\verb.Table. и \verb.Figure., которые принимают следующие 
аргументы:
\begin{enumerate}
\item Необязательный параметр, указывающий предпочтительное место 
(h,p,t,b) расположения таблицы или рисунка. Не рекомендуется указывать этот
параметр без необходимости.
\item Название рисунка/таблицы.
\item Метка, на которую должна присутствовать ссылка в тексте работы.
\end{enumerate}
                                      
Замечания и предложения по использованию пакета следует направлять доц. 
Трифонову П.В. на адрес petert@dcn.ftk.spbstu.ru.

\end{document}
